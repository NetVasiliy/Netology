#В виде результата напишите текстом ответы на вопросы и каким образом эти ответы были получены. 

1. **Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.**  

 Это команда встроенная в SHELL. Для перехода по директориям внутри интерпретатора.

2. **Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос.**     
   
   
    vagrant@vagrant:~$ cat TMP  
    111  
    222  
    333  
    444 4444 444  
    333  
    444
    vagrant@vagrant:~$ grep 333 TMP | wc -l   
    2  
    vagrant@vagrant:~$ grep 333 TMP -c  
    2  

3. **Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?**  
***команда pstree показывает,что все процессы являются дочерними для systemd***
  

***systemd***  

    top  
    1 root         0:02.45 systemd
----------------------------------
	sudo lsof|less
Сразу видно, что PID 1 у systemd  

	COMMAND    PID TID TASKCMD              USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
	systemd      1                          root  cwd       DIR              253,0     4096          2 /
--------------------------------
***init***  

	ps -aux
	root           1     0:02 /sbin/init

Вопрос: Как так?  

4. **Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?**  

На первом терминале выполним  

    lsof -p $$ -покажет, что я в /dev/pts/1
На втором терминале выполним  

	lsof -p $$ -покажет, что я в /dev/pts/2
На первом терминале выполним  

	ls abrakadabra 2>/dev/pts/2
На втором терминале получим  

	ls: cannot access 'abrakadabra': No such file or directory  

5. **Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.**  
  

    cat /home/vagrant/tmp/err2 >>~/tmp/err3  

6. **Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?**  
  
Если честно не очень понял вопрос. Так пойдет?  

	echo " i am COOL!" > /dev/pts/2  

Немного подумав нашел такой способ:
-Подключаюсь из VirtualBox под пользователем root - для наблюдения.  
-Из терминала Vagrant запускаю: 

	sudo bash
	echo "I am COOL!" > /dev/tty1  

-Наблюдаю в VirtualBox  

	I am COOL!  
Можно перекинуть в любую tty.  

7. **Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?**  

bash 5>&1 запустит экземпляр bash, в котором 5й дескриптор перенаправлен в stdout.  

    echo netology > /proc/$$/fd/5 выведет "netology"  

Так происходит из-за того, что echo кидает в 5й дескриптор, а он перенаправлен в stdout.  
  
8. **Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.**  
    


        vagrant@vagrant:~$ ls ~/tmp2  
        cannot access '/home/vagrant/tmp2': No such file or directory  
        varant@vagrant:~$ ls ~/tmp2 6>&2 2>&1 1>&6 | wc -l  
        1  
Не уверен, что это верно... Не смог выполнить условие: "не потеряв при этом отображение stdout на pty"  

9. **Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?**  
  
  
    vagrant@vagrant:~$ cat /proc/$$/environ  
    USER=vagrantLOGNAME=vagrantHOME=/home/vagrantPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binSHELL=/bin/bashTERM=xterm-256colorXDG_SESSION_ID=1XDG_RUNTIME_DIR=/run/user/1000DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/busXDG_SESSION_TYPE=ttyXDG_SESSION_CLASS=userMOTD_SHOWN=pamLANG=en_US.UTF-8LANGUAGE=en_US:SSH_CLIENT=10.0.2.2 57521 22SSH_CONNECTION=10.0.2.2 57521 10.0.2.15 22SSH_TTY=/dev/pts/0  

Это переменные окружения  
Похожий вывод у команды "env"  
  
10. **Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe**  
  
***/proc/<PID>/cmdline*** - Это файл, который содержит полную командную строку для процесса, если только процесс не является зомби.  

***/proc/<PID>/exe*** - Это файл, который представляет собой символическую ссылку, содержащую фактический путь к исполняемому файлу.  
  
11. **Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo**  
  

    cat /proc/cpuinfo |grep sse  
    sse4_2  
   
12. **При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:**  
  

    vagrant@netology1:~$ ssh localhost 'tty'
    not a tty  
**Почитайте, почему так происходит, и как изменить поведение.**  
  
Поддержка tty не доступна на устройстве ввода.  
По умолчанию при выполнении команды на удаленной машине с использованием ssh для удаленного сеанса не выделяется TTY. Это позволяет передавать двоичные данные и т. Д. без необходимости иметь дело с причудами TTY.  

Не понял почему так происходит, но нашел ключ -t. С ним по другому.  

Без "-t"  
  
    ssh localhost 'tty'
	not a tty  

С ключем "-t"  
  
    ssh -t localhost 'tty'
	/dev/pts/4
	Connection to localhost closed  
  
13. **Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.**  
  
Такой утилиты у меня не было. Пришлось поставить.  

	sudo apt install reptyr  

Синтаксис: reptyr [PID]

Запустил в одной консоли "top", посмотрел его PID из второй консоли  
"ps -a" - 2428.  

Набрал "reptyr 2428" и увидел его во второй консоли, правда в неудобоваримом виде и без возможности остановить.  
Пришлось килять.  
  
14. **sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.**  
   
tee - считывает данные из стандартного устройства ввода и записывает их на стандартное устройство вывода или в файл.  

Ответ на вторую часть вопроса заключен в самом вопросе:  
"так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем".  
А команда "tee" запускается с правами root-а.



